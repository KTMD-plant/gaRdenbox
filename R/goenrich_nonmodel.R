#goseq for non model species

#Author: Kilian Duijts


#helper functions


#funciton that generates named list of go terms from input df with 2 columns: geneid: geneids, go: "GO:0071396, GO:0042742, GO:0042742, GO:0009737"

#' @title gene2go
#' 
#' @description 
#' Converts a two column dataframe to a named list (as required for goseq_nm). 
#' 
#' 
#' @param df_gene2go takes a dataframe of two columns. The first column should contain only single geneids. The second column should contain a string containing GO:terms separated by ",".
#' 
#' @export
f_gene2go<-function(df_gene2go){
  
  geneid2go<-list()
  
  i=1
  for (i in seq(1:nrow(df_gene2go))) {
    
    geneid<- df_gene2go[i,1]%>%paste()
    
    golong<-df_gene2go[i,2]%>%paste()
    
    goready<-str_extract_all(string = golong,pattern = "GO:[:digit:]{7}")
    
    names(goready)<-geneid
    
    
    geneid2go[geneid]<-goready
    
    i=i+1
  }
  
  return(geneid2go)
}

#helper function generating go2geneid list

#' @title go2geneid
#' 
#' @description generates the inverse of geneid2go
#' 
#' @details takes a named list of GO-terms, as generated by geneid2go. Generates the inverse of the input.
#' 
#' 
#' @param geneid2go takes a named list of GO-terms. List elements should be GO-terms. Names are corresponding geneids.
#' 
#' @export
f_go2geneid<-function(geneid2go){
  
  go2geneid<-split(rep(names(geneid2go), lengths(geneid2go)), unlist(geneid2go))
  
  
  return(go2geneid)
}

#function to extract genelengths

#' @title Extract gene length from fasta file
#' 
#' @description Extracts length of genes from fasta file into a named list.
#' 
#' @details uses biostrings to import fastafiles
#' 
#' @param fasta_file Path to a fasta file containing the genes of interest
#' 
#' 
#' @export
f_genelength<-function(fasta_file){
  cdna<-Biostrings::readDNAStringSet(fasta_file)
  
  #get the length of each transcript
  bias_cdna<-Biostrings::width(cdna)
  
  
  #get the corresponding geneid
  
  
  a<-tibble(Sp=names(cdna)) %>%
    separate(Sp,into="Sp2",sep=" ",extra="drop") %>%
    dplyr::select(Sp2) %>% 
    as.vector()
  
  names(bias_cdna)<-a$Sp2
  
  return(bias_cdna)
}



#' @title Gene Ontology testing for non-model species
#' @description 
#' Re-application of the goseq ("https://bioconductor.org/packages/release/bioc/html/goseq.html") package for use on non model species.
#' This is based on a tutorial ("https://knozue.github.io/post/2018/10/17/over-representation-analysis-3-goseq-with-non-model-go-term.html") by knozue
#' @details 
#' The function makes it easier to test gene sets of non-model species.
#' 
#' It takes the following parameters:
#' 
#' @param querylist A list with for each element a non-model species gene id.
#' @param padj Numerical value specifying the cut-off for the adjusted pvalue
#' 
#' # method <currently not available>
#' 
#' @param geneid2go A named list for which the names are geneids and the list elements consist of GO-terms (like so: GO:0006355). Please make sure your geneid's are identical to the query genes.
#' @param bias_cdna fasta file containing the non-model species geneid's and their sequences. The gene lenght is used for the probabily weight; normalization for gene length.
#' @param testingmethod OPTIONAL specify what method to use to calculate adjusted pvalues. Arguments are past to p.adjust() from stats; see ?p.adjust for all options. 
#' If left empty Benjamini & Hochberg ("BH") is used by default.
#' 
#' @author Kilian Duijts
#' 
#' 
#' 
#' 
#' @export
goseq_nm<-function(  #fuction runs goseq for non-modelspecies
  querylist,                 #provide query list
  padj,                     #choose padj thresshold
  geneid2go,                #provide named list. names=geneid, list elements goterms
  bias_cdna,                      #output from f_getgenelength
  testingmethod

  
  ){
  
  
  #get querylist to test in named binary list
  tgl<-as.integer(
    names(bias_cdna) %in% querylist)
  
  names(tgl)<-names(bias_cdna)
  
  
  #calculate probability weighting
  pw<-goseq::nullp(tgl, bias.data = bias_cdna,plot.fit = TRUE)
  
  #Plot pw
  
  # png(filename = )
  # plotPWF(pw)
  # 
  # dev.off()
  # 
  
  #perform goseq
  goseq_out<-goseq::goseq(pwf = pw, gene2cat = geneid2go)
  
  
  #Calculate adjusted pvalues

  #default to BH
  if (
    missing(testingmethod) ) {
    
    testingmethod<-"BH"
  }
    
    colpadj<-paste("padj", testingmethod, sep="_")
    
    goseq_out[, colpadj] <- p.adjust(goseq_out[, 2], method = testingmethod)


  
  
  #filer on adjusted pvalues
  GOenriched <- goseq_out[which(goseq_out[, colpadj] < padj), ]
  
  #get list of quarygenes with associated goterms
  y <- querylist[querylist %in% names(geneid2go)]
  
  
  #if any go-enrichments are found, report the total, and number of genes
  if(nrow(GOenriched) != 0){
    GOenriched["Total"] <- nrow(pw)
    GOenriched["ClusterSize"] <- length(y)
    
    #We also want to know what genes contributed to the go term to be deemed enriched.
    #here we pre-allocate a dataframe to do this.
    go2glgenes<-data.frame("category"=character(),
                           "geneid"=character())
    
    
    #generate go2geneid named list to look up connections
    
    go2geneid<-f_go2geneid(geneid2go = geneid2go)
    
    #Looping through go terms to find the corresponding geneid's
    for (j in GOenriched$category) {
      
      a<-go2geneid[[j]]
      
      #check if go-associated genes are present in the querylist
      gogenes<-a[a%in%querylist]%>%
        unlist()
      
      #add to dataframe
      df<-data.frame("category"=j,
                     "geneid"=paste(gogenes, 
                                    collapse = ","
                     )
      )
      #append to collection dataframe
      go2glgenes<-rbind(go2glgenes, df)
      
    }
    
    #join to final output dataframe
    GOenriched<-left_join(GOenriched, go2glgenes)
    
    
    
    
  }
  
  
  return(GOenriched)
  
}           

